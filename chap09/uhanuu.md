## 9.1 개요

실행 계획을 이해할 수 있어야만 더 최적화된 방법으로 실행 계획을 수립하도록 유도할 수 있다.

### 9.1.1 쿼리 실행 절차

MySQL 서버에서 쿼리가 실행되는 과정은 크게 3단계로 나눌 수 있다.

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번쨰 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

### 9.1.2 옵티마이저의 종류

1. 현재 대부분의 DBMS가 선택하고 있는 **비용 기반 최적화**(Cost-based-optimizer, CBO) 

쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, **각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출**한다.

- 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행

1. 예전 초기 버전의 오라클 DBMS에서 많이 사용했던 **규칙 기반 최적화**(Rule-based-optimizer, RBO)

대상 테이블의 **레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립**한다.

- 사용자의 데이터는 분포도가 매우 다양하지만 같은 쿼리에 대해서는 거의 항상 같은 실행계획을 만들어 거의 사용되지 않는다.

## 9.2 기본 데이터 처리

DBMS들은 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다.

- 결과물은 동일하더라도 RDBMS별로 그 결과가 천차만별이다.
- 기본적인 가공을 위해 MySQL 서버가 어떤 알고리즘을 사용하는지 살펴보자.

### 풀 테이블 스캔과 풀 인덱스 스캔

---

MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔(인덱스 X)을 선택한다.

- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
(일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

MySQL의 InnoDB에서 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다. **(풀 테이블 스캔, 풀 인덱스 스캔 둘다)**

**리드 어헤드:** 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것을 의미한다.

- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 **특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.**
- 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시킨다. (최대 64개의 데이터 페이지까지 읽어서 버퍼풀에 저장)
- 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 포그라운드 스레드 쿼리가 상당히 빨리 처리된다.

innodb_read_ahead_threshold 시스템 변수를 통해 언제 리드 어헤드를 시작할지 임계값 설정이 가능하다.

- default 값도 충분하지만 데이터 웨어하우스용으로 MySQL을 사용한다면 이 옵션을 더 낮은 값으로 설정해서 더 빨리 리드 어헤드가 시작되게 유도하는 것도 좋은 방법이다.

### 병렬 처리

---

MySQL 8.0 버전에서 아무런 WHERE 조건 없이 단순히 테이블의 건수를 가져오는 쿼리만 병렬처리할 수 있다.

```sql
SET SESSION innodb_parallel_read_threads=4;
SELECT COUNT(*) FROM TABLE_TAME;
```

- innodb_parallel_read_threads 시스템 변수를 사용하면 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경할 수 있다.
- 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어들지만 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있다.

### ORDER BY 처리(Using filesort)

---

|  | 장점 | 단점 |
| --- | --- | --- |
| Filesort 이용 | 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점이다. 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다. | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다. |

모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능하다.

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

### 소트 버퍼

---

MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.

레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 MySQL은 레코드를 여러 조각으로 나눠서 정렬하고 결과를 임시로 디스크에 저장한다. 그 다음 레코드를 디스크에 가져와서 정렬하고 디스크에 임시 저장하는 것을 반복한다.

- 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬하는데 이 병합 작업을 멀티 머지라고 표현하며 수행된 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수(SHOW STATUS VARIABLES 명령)에 누적해서 집계된다.
- 디스크 쓰기와 읽기를 유발하며, 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아진다.
- 소트 버퍼는 글로벌 메모리 영역이 아닌 세션(로컬) 메모리 영역애 해당하기 때문에 커넥션, 정렬 작업이 많아질수록 소트 버퍼로 소비되는 메모리 공간이 커지게 된다.
- 소트 버퍼를 크게 설정하면 I/O 작업은 줄어들지만 벤치마크 결과로는 큰 차이를 보이지 않으며 리눅스 계열의 운영체제에서는 너무 큰 sort_buffer_size를 사용하면 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있다.

### 정렬 알고리즘

---

레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 싱글 패스, 투 패스 2가지 정렬 모드로 나눌 수 있다.

- 옵티마이저 트레이스 기능을 통해 쿼리가 어떤 정렬 모드를 사용하는지 확인 가능하다.

### 싱글 패스 정렬 방식

---

소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.

- 처음 table을 읽을 때 정렬에 필요하지 않은 컬럼까지 전부 읽어서 소트 버퍼에 담고 정렬을 수행한다.
- SELECT 쿼리에서 모든 컬럼(*)을 가져오도록 하면 정렬 버퍼를 몇 배에서 몇십 배까지 비효율적으로 사용할 가능성이 크다. (임시 테이블이 필요한 쿼리에서도 영향을 미친다.)

### 투 패스 정렬 방식

---

정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬방식이다.

- 투패스 방식은 테이블을 두 번 읽어야 하지만 싱글 패스는 그렇지 않다. 하지만 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요하다.
- 정렬 대상 레코드의 크기나 건수가 작을 때는 싱글 패스 방식이 빠른 성능을 보이며, 상당히 클 때는 투 패스 방식이 효율적이라고 볼 수 있다.

최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용하지만 다음의 경우 투 패스 정렬 방식을 사용한다.

- 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할 때

### 정렬 처리 방법

---

쿼리에서 ORDER BY가 사용되면 다음 3가지 처리 방법 중 하나로 정렬 처리된다.

- 위에서 아래로 갈수록 처리 속도는 떨어진다.

| 정렬 처리 방법 | 실행 계획의 Extra 칼럼 내용 |
| --- | --- |
| 인덱스를 이용한 정렬 | 별도 표기 없음 |
| 조인에서 드라이빙 테이블만 정렬 | Using filesort |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | Using temporary; Using filesort |

인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)하는데 MySQL 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 2가지 방법 중 하나를 선택한다.

- 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

조인이 수행되면서 레코드 건수와 크기는 거의 배수로 불어나기 때문에 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다.

### 인덱스를 이용한 정렬

---

인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다. 또한  WHERE절에 첫 번쨰로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.

- MySQL 서버는 정렬을 인덱스로 처리할 수 있는 경우 부가적으로 불필요한 정렬을 하지 않는다. 
(B-Tree 인덱스가 키 값으로 정렬되어 있기 때문이다.)
- 조인이 네스티드-루프 방식으로 실행되므로 조인 때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.
- 실행 계획에 조인 버퍼(Join buffer)가 사용되면 순서가 흐트러질 수 있기 때문에 주의해야 한다.

실행 계획이 조금 변경되면 인덱스를 사용하지 못하고 버그로 이어질 수 있으니 ORDER BY를 명시하자.

### 조인의 드라이빙 테이블만 정렬

---

사용할 수 있는 인덱스가 없다면 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이다.

조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY 절을 작성해야 한다.

- 옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행(Filesort)하고 정렬된 결과를 순서대로 읽으면서 드리븐 테이블과 조인을 수행한다.

### 임시 테이블을 이용한 정렬

---

2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다. 

드라이빙 테이블만 정렬을 이용한 방식 외에는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.

```sql
SELECT *
FROM employees s, salaries s
WHERE s.emp_no = e.emp_no
	AND s.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary;
```

- 정렬 기준 칼럼이 드리븐 테이블에 컬럼이므로 정렬이 수행되기 전에 salaries 테이블을 읽어야 하므로 이 쿼리는 조인된 데이터를 가지고 정렬할 수밖에 없어 조인 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리해야 한다.

### 정렬 처리 방법의 성능 비교

---

ORDER BY나 GROUP BY 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수 만큼만 가져와서 처리할 수 없다. 

- 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 실행해야만 비로소 LIMIT으로 제한할 수 있기 때문에 WHERE 조건이 인덱스 튜닝이 잘 되어 있어도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 많다.

### 스트리밍 방식

---

서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로 클라이언트로 전송해주는 방식

### 버퍼링 방식

---

ORDER BY, GROUP BY는 쿼리의 결과가 스트링되는 것을 불가능하게 한다. 우선 WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그로핑해서 차례대로 보내야 하기 때문이다.

- MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려진다.
- 정렬 처리 방법 중에서 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지는 모두 버퍼링된 후에 정렬된다.

### 정렬 관련 상태 변수

---

MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장한다. 

정렬과 관련해서도 지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼간의 병합 작업은 몇 번이나 발생했는지 등을 확인할 수 있다.

```sql
FLUSH STATUS;
SHOW STATUS LIKE 'Sort%';
```

## 9.2.4 GROUP BY 처리

GROUP BY는 ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나다.

GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠 볼 수 있다.

인덱스를 이용할 때는 인덱스를 차례대로 읽는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법으로 나뉜다. 그리고 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용한다.

### **인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)**

---

ORDER BY의 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼을 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.

- 인덱스를 사용하더라도 그룹 함수의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다.

### **루스 인덱스 스캔을 이용하는 GROUP BY**

---

루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미하는데, 옵티마이저가 루스 인덱스 스캔을 사용할 떄는 실행 계획의 Extra 칼럼에 "Using index for group-by"라고 표시된다.

MySQL의 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있으며 프리픽스 인덱스는 루스 인덱스 스캔을 사용할 수 없다.

- 루스 인덱스 스캔으로 처리되는 쿼리에서는 별도의 임시 테이블이 필요하지 않다.

### 임시 테이블을 사용하는 GROUP BY

---

GROUP BY의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.

- MySQL 8.0 부터는 GROUP BY가 사용된 쿼리는 그루핑되는 칼럼을 기준으로 묵시적인 정렬은 더 이상 실행되지 않아 Using filesort는 표시되지 않고 Using temporary만 표시된다.
- 내부적으로 GROUB BY 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들기 때문에 Using temporary가 표시된다. 
(유니크 인덱스가 정렬되어 있어 조인의 결과를 한 건씩 가져오면 별도 정렬 작업이 없어도 되기 때문이다.)

GROUP BY와 ORDER BY가 같이 사용되면 명시적으로 정렬 작업이 실행되므로 Using filesort와 함께 Using temporary가 표시된다.

## 9.2.5 **DISTINCT 처리**

집합 함수와 같이 DISTINCT를 사용하는 경우와 집합 함수가 없이 사용하는 각 경우에 DISTINCT 키워드가 영향을 미치는 범위가 달라진다.

### **SELECT DISTINCT ...**

SELECT 되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용한다. 이 경우 GROUP BY와 동일한 방식으로 처리된다. 

```sql
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROM salaries GROUP BY emp_no;
```

- MySQL 8.0 버전부터는 GROUP BY를 수행하는 쿼리에 ORDER BY 절이 없으면 정렬을 사용하지 않기 때문에 다음의 두 쿼리는 내부적으로 같은 작업을 수행한다.

DISTINCT는 SELECT하는 레코드(튜플)을 유니크하게 SELECT하는 것이지, 특정 칼럼만 유니크하게 조회하는게 아니다.

```sql
select distinct first_name, last_name from user;
select distinct (first_name), last_name from user;
```

- DISTINCT는 함수가 아니므로 괄호가 의미 없어지고 (first_name, last_name) 조합 전체가 유니크하게 가져오는 것이다.

### **집합 함수와 함께 사용된 DISTINCT**

---

집합 함수가 없는 SELECT 쿼리에서 DISTINCT는 조회하는 모든 칼럼의 조합이 유니크한 것들만 가져온다.하지만 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져온다.

- 집합 함수와 같이 DISTINCT가 사용되는 쿼리의 실행 계획에 Using temporary가 출력되지 않지만 실제로 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요하다.

```sql
SELECT COUNT(DISTINCT s.salary),
	  	 COUNT(DISTINCT e.last_name)
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
	AND e.emp_no BETWEEN 100001 AND 100100;
```

- employees 테이블과 salaries 테이블을 조인한 결과에서 집계함수에 DISTINCT로 사용한 칼럼에는 각각 유니크 인덱스가 생긴다. 따라서 위에 쿼리는 2개의 임시 테이블을 사용한다.
- DISTINCT 처리를 위한 인덱스가 있으면 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행할 수 있다.

### **9.2.6 내부 임시 테이블 활용**

---

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블을 사용한다.

- `내부적`이라는 단어가 포함된 이유는 `CREATE TEMPORARY TABLE` 명령으로 만든 임시 테이블과는 다르다.
- MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능하다. 또한 쿼리의 처리가 완려되면 자동으로 삭제된다.

일반적으로 MySQL 엔진이 사용하는 임시 테이블을 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다.

- 특정 예외 케이스에는 메모리를 거치지 않고 바로 디스크에 임시 테이블이 만들어지기도 한다.

### **메모리 임시 테이블과 디스크 임시 테이블**

---

MySQL 8.0 버전부터는 MEMORY 스토리지 엔진 대신 가변 길이 타입을 지원하기 위해 메모리는 TempTable스토리지 엔진을 사용하고, 디스크에 저장되는 임시 테이블은 MyISAM 스토리지 엔진에서 트랜잭션 지원 가능한 InnoDB를 사용하도록 개선됐다.

### **임시 테이블이 필요한 쿼리**

---

다음 패턴의 쿼리는 별도의 데이터 가공 작업을 필요로 하므로 대표적으로 내부 임시 테이블을 생성하는 케이스다.

1. ORDER BY, GROUP BY에 명시된 칼럼이 다른 쿼리
2. ORDER BY, GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
3. DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
4. UNION이나 UNION DISTINCT가 사용된 쿼리
5. 쿼리의 실행 계획에서 select_type이 DERIVED인 경우

```
[3~5]: Using temporary가 표시되지 않을 때도 임시 테이블을 사용할 수 있다.
[1~4]: 유니크 인덱스를 가지는 내부 임시 테이블이 만들어진다.
[5]: 유니크 인덱스가 없는 내부 임시 테이블이 생성된다.
```

- 유니크 인덱스가 있는 내부 임시 테이블은 그렇지 않은 쿼리보다 상당히 처리 성능이 느리다. (빠르지 않나..?)

### **임시 테이블이 디스크에 생성되는 경우**

---

다음과 같은 조건을 만족하면 메모리 임시 테이블을 사용할 수 없어 디스크 기반의 임시 테이블을 사용하게 된다.

- UNION, UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 (MEMORY 스토리지 엔진에서) tmp_table_size 또는 max_heap_table_size 시스템변수보다 크거나 (TempTable 스토리지 엔진에서) temptable_max_ram 시스템 변수 값보다 큰 경우

### **임시 테이블 관련 상태 변수**

---

`Using temporary` 가 표시되어 임시 테이블을 사용한 사실은 알 수 있지만 임시 테이블이 메모리에서 처리됐는지 디스크에서 처리됐는지는 알 수 없으며, 몇 개의 임시 테이블이 사용됐는지도 알 수 없다.

```sql
FLUSH STATUS; # 테스트 쿼리를 실행하기 전에 현재 세션의 상태 값 초기화
SELECT ... FROM ... # 테스트 쿼리

SHOW SESSION STATUS LIKE 'Created_tmp%'; # 임시 테이블 확인
```

- Created_tmp_disk_tables : 디스크에 내부 임시 테이블의 개수를 누적한 값 (밑에서 빼면 메모리 인듯)
- Created_tmp_tables : 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 누적 개수(메모리, 디스크 구분X)

## 9.3 고급 최적화

MySQL 서버의 옵티마이저가 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립하게 된다.

- 옵티마이저 옵션은 크게 조인 관련된 옵티마이저 옵션과 옵티마이저 스위치로 구분하 수 있다.
- `조인 관련된 옵티마이저 옵션`은 조인이 많이 사용되는 서비스에서는 알아야 하는 옵션이며 `옵티마이저 스위치`는 MySQL 서버의 고급 최적화 기능들을 활성화할지를 제어하는 용도로 사용된다.

## **옵티마이저 스위치 옵션**

옵티마이저 스위치 옵션은 optimizer_switch 시스템 변수를 이용해서 제어한다.

옵티마이저 스위치 옵션은 글로벌과 세션별 모두 설정할 수 있는 시스템 변수이므로 MySQL 서버 전체적으로 또는 현재 커넥션에 대해서만 설정할 수 있다.

```sql
# MySQL 서버 전체적으로 옵티마이저 스위치 설정
SET GLOBAL optimizer_switch='index_merge=on, index_merge_union=on, ...';

# 현재 커넥션의 옵티마이저 스위치만 설정
SET SESSION optimizer_switch='index_merge=on, index_merge_union=on, ...'; 

# SET_VAR 옵티마이저 힌트를 이용해 현재 쿼리에만 설정할 수도 있다.
SELECT /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off') */
	...
	FROM ...
```

### **MRR과 배치 키 액세스(mrr & batched_key_access)**

---

MRR은 Multi-Range Read의 약자로서, 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인버퍼에 버퍼링한다.  즉, 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링하는 것이다.

- 조인 버퍼에 레코드가 가득 차면 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진에 한번에 요청한다.
- 스토리지 엔진을 읽어야 할 레코드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화할 수 있다.
- MMR을 응용해서 실행되는 조인 방식을 BKA 조인이라고 하며 부가적인 정렬 작업이 필요해지면서 성능에 안좋을 수 있기 때문에 기본적으로 비활성화 되어있다.

### **블록 네스티드 루프 조인(block_nested_loop)**

---

MySQL 사용되는 대부분의 조인은 네스티드 루프 조인인데, 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.

- 드리븐 테이블의 풀테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면, 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리하는데 이 때 사용되는 메모리의 캐시를 **조인 버퍼**라고 한다.
- 조인 버퍼가 사용되면 실제 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리되기 때문에 정렬 순서가 흐트러질 수 있다.
- 해시 조인 알고리즘으로 대체되어 사용되면서 MySQL 8.0.20 이후의 버전이라면 `Using Join Buffer(block nested loop)` 메시지는 표시되지 않을 수 있다.

### **인덱스 컨디션 푸시다운(index_condition_pushdown)**

---

인덱스를 비교하는 작업은 실제 InnoDB 스토리지 엔진이 수행하지만 테이블의 레코드에서 칼럼 조건을 비교하는 작업은 MySQL 엔진이 수행하는 작업이다.

- MySQL 5.5 버전 까지는 인덱스를 범위 제한 조건으로 사용하지 못하는 조건은 MySQL 엔진이 스토리지 엔진으로 아예 전달해주지 않으면서 불필요한 읽기가 발생했다.

MySQL 5.6 버전 부터 인덱스를 범위 제한 조건으로 사용하지 못해도 인덱스에 포함된 칼럼의 조건이 있다면 같이 모아 스토리지 엔진에 전달할 수 있게 핸들러 API가 개선되었다.

- 옵티마이저 스위치 옵션 `index_condition_pushdown` 를 끄고, 키고 해보면 `Using Where` 은 없어지고 `Using index condition` 이 출력된다. (쿼리 성능 몇 배 ~ 몇십 배 개선 가능)

### 인덱스 확장(use_index_extensions)

---

use_index_extensions 옵티마이저 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.

- 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 프라이머리 키 칼럼을 순서대로 포함하기 때문이다.

## 인덱스 머지(index_merge)

인덱스를 이용해 쿼리를 실행하는 경우, 대부분 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립한다. 하지만 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다.

index_merge 옵티마이저 옵션은 아래 3개의 최적화 옵션을 한 번에 모두 제어할 수 있는 옵션이다. 

- **`index_merge_intersection`, `index_merge_union`, `index_merge_sort_union`**

### **인덱스 머지 - 교집합(index_merge_intersection)**

---

쿼리에서 인덱스 2개 중에서 어떤 조건을 사용하더라도 인덱스를 사용할 수 있을 때 인덱스를 교집합으로 사용한다면 하나의 인덱스를 통해 값을 검색하고 가져오는것보다 불필요한 검색의 수를 줄일 수 있다.

아래 쿼리에서 first_name 인덱스는 PK인 emp_no 칼럼을 자동으로 포함하고 있기 때문에 first_name 인덱스만 사용하는 것이 더 성능이 좋을 것으로 생각할 수 있다.

- WHERE first_name=’Georgi’ AND emp_no BETWEEN 10000 AND 20000;
`Using intersect(ix_firstname, PRIMARY); Using where)`
- idex_merge_intersection 최적화를 비활성화 하면 된다. 
(현재 커넥션, 현재 쿼리에 대해서만 비활성할 수도 있다.)

### **인덱스 머지-합집합(index_merge_union)**

---

`Using union(ix_firstname, ix_hiredate);` 는 WHERE 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 OR 연산자로 연결된 경우에 사용되는 최적화다.

- 두 결과 집합에서 중복을 제거하기 위해서는 정렬 작업이 필요한데 인덱스로 검색한 결과가 각각 PK로 이미 정렬되어 있기 때문에 filesort 작업은 따로 일어나지 않는다.
- 두 집합에서 하나씩 가져와서 서로 비교하면서 PK 값이 중복된 레코드들을 정렬 없이 걸러낼 수 있다.
(우선순위 큐 알고리즘)

### **인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)**

---

인덱스 머지 작업을 하는 도중에 결과의 정렬이 필요한 경우 MySQL 서버는 인덱스 머지 최적화의 `Sort Union`알고리즘을 사용한다.

## **세미 조인(semijoin)**

다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리를 세미 조인이라고 한다.

**세미 조인 쿼리(`= (subquery)`, `IN (subquery)`)에 대해 최적화 방법**

1. 세미 조인 최적화
2. IN-to-EXISTS 최적화
3. MATERIALIZATION 최적화

 **`<> (subquery)`형태와 `NOT IN (subquery)` 형태의 안티 세미 조인 쿼리에 2가지 최적화 방법**

1. IN-to-EXISTS 최적화
2. MATERIALIZATION 최적화

**세미 조인 쿼리의 성능을 개선하기 위한 최적화 전략**

- Table Pull-out
- Duplicate Weed-out
- First Match
- Loose Scan
- Materialization

### **테이블 풀-아웃(Table Pull-out)**

---

Table pullout 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 죄적화다. 이는 서브쿼리 최적화가 도입되기 이전에 수동으로 쿼리를 튜닝하던 대표적인 방법이였다. (MySQL에서는 가능하다면 table pullout 최적화를 최대한 적용한다.)

- 실행 계획에서 table이 동일한 id를 가진다는 것은 두 테이블이 서브쿼리 형태가 아니라 조인으로 처리됐음을 의미한다.
- Table Pullout 최적화는 별도로 실행 계획의 Extra 컬럼에 `Using table pullout` 과 같은 문구가 출력되지 않는다. (id 컬럼으로 구분)
- SHOW WARNINGS 명령으로 옵티마이저가 재작성한 쿼리를 살펴볼 수 있다.
- Table Pullout 최적화는 서브쿼리를 조인으로 풀어서 사용하라는 튜닝 가이드를 그대로 실행하는 것이라서 서브쿼리를 조인으로 풀어서 사용할 필요가 없다.

### **퍼스트 매치(firstmatch)**

---

First match 최적화 전략은 `IN (subquery)` 형태의 세미 조인을 `EXISTS(subquery)` 형태로 튜닝한 것과 비슷한 방법으로 실행된다.

- 테이블의 레코드에 대해 서브 쿼리 테이블에 일치하는 레코드 1건만 찾으면 더이상의 서브 쿼리 테이블 검색을 하지 않는다는 것을 의미한다. (단축 실행 경로 Short-cut path)
- optimizer_switch 시스템 변수에서 semijoin 옵션과 firstmatch 옵션이 모두 ON으로 활성화된 경우에만 사용할 수 있다.

**FirstMatch 최적화가 성능 향상에 별로 도움을 주지 않을 때**

```sql
SELECT * FROM employees e
WHERE e.emp_no IN (
	SELECT de.emp_no FROM dept_emp de
	WHERE de.from_date = '1999-01-01');
```

- employees 테이블에 대한 조건이 서브쿼리 이외에는 아무것도 없기 때문에 employees 테이블을 풀 스캔해야 한다. (다른 WHERE 절 조건이 필요)

**FirstMatch 최적화의 몇 가지 제한 사항과 특성**

- FirstMatch 최적화에서 서브쿼리는 그 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다.
- FirstMatch 최적화가 실행되면 실행 계획의 Extra 칼럼에는 `FirstMatch(table-N)` 문구가 표시된다.
- FirstMatch 최적화는 상관 서브쿼리(Correlated subquery)에서도 사용될 수 있다.
- FirstMatch 최적화는 GROUP BY나 집합 함수가 사용된 서브쿼리의 최적화에는 사용될 수없다.

### **루스 스캔(loosescan)**

---

세미 조인 서브쿼리 최적화의 LooseScan은 인덱스를 사용하는 GROUP BY 최적화 방법에서 살펴본 `Using index for group-by`의 루스 인덱스 스캔과 비슷한 읽기 방식을 사용한다.

```sql
SELECT * FROM departments d WHERE d.dept_no IN ( # departments 9건
	SELECT de.dept_no FROM dept_emp de ); # dept_emp 33만 건
```

- dept_emp 테이블에 (dept_no + emp_no) 칼럼의 조합으로 PK 인덱스가 만들어져 있으면 dept_emp 테이블이 드라이빙 테이블로 실행되며 dept_no 부분에서 유니크하게 한 건씩만 읽을 수 있다.
    - 서브쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화다.
- 실행 계획의 id 칼럼의 값이 동일하게 1로 나와 join으로 처리될 수 있으며 `LooseScan` 이라고 출력된다.
    - materialization, firstmatch, duplicateweedout 옵션을 다 off로 설정하고 테스트 했다.

### **구체화(Materialization)**

---

Materialization는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미다. 

- 구체화는 쉽게 표현하면 내부 임시 테이블을 생성한다는 것을 의미한다.

```sql
SELECT * FROM employees e
WHERE e.emp_no IN (
	SELECT de.emp_no FROM dept_emp de
	WHERE de.from_date = '1999-01-01');
```

- 서브쿼리가 먼저 실행되어 그 결과로 구체화된 임시테이블이 만들어지고 employees 테이블을 조인해서 결과를 반환한다.
- optimizer_switch 시스템 변수에서 semijoin 옵션과 materialization 옵션이 모두 ON으로 활성화 되어 있어야 한다. (MySQL 8.0 default로 둘다 ON)

Materialization 최적화의 제한 사항과 특성

- IN (subquery)에서 서브쿼리는 상관 서브쿼리가 아니어야 한다.
- 서브쿼리는 GROUP BY나 집합 함수들이 사용돼도 구체화를 사용할 수 있다.
- 구체화가 사용된 경우에는 내부 임시 테이블이 사용된다.

### **중복 제거(Duplicated Weed-out)**

---

Duplicated Weed-out은 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘이다.

- 실행 계획에 Duplicated Weedout이라는 문구가 표시되지 않고 `Start/End temporary` 가 표시된다.

Duplicated Weed-out 최적화의 장점과 제약 사항

- 서브쿼리가 상관 서브쿼리라고 하더라도 사용할 수 있는 최적화다.
- 서브쿼리가 GROUP BY나 집합 함수가 사용된 경우에는 사용될 수 없다.
- Duplicate Weed-out은 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많다.

### **컨디션 팬아웃(condition_fanout_filter)**

---

MySQL 옵티마이저는 여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행하는데 이를 컨디션 팬아웃이라고 한다.

- 조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미치기 때문이다.

condition_fanout_filter 최적화 기능을 활성화하면 쿼리의 실행 계획 수립에 더 많은 시간과 컴퓨팅 자원을 사용하게 된다.

- MySQL 서버가 처리하는 쿼리의 빈도가 매우 높다면 실행 계획 수립에 추가되는 오버헤드가 더 크게 보일 수 있으므로 업그레이드를 실행하기 전 성능 테스트를 진행하는 것이 좋다.

### **파생 테이블 머지(derived_merge)**

---

예전 버전의 MySQL 서버에서는 FROM 절에서 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분을 처리했다. 

- FROM 절에 사용된 서브쿼리를 파생 테이블 (Derived Table)이라고 부른다.
- 임시테이블의 크기가 커지면 메모리로 해결할 수 없어 디스크 I/O가 발생되며 레코드가 많아질 수록 쿼리의 성능은 느려지게 된다.

MySQL 5.7 부터는 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화가 도입됐다. derived_merge는 이러한 임시 테이블 최적화를 활성화할지 여부를 결정한다.

아래 조건에서는 옵티마이저가 자동으로 서브쿼리를 외부 쿼리로 병합할 수 없다. (수동으로 병합해서 작성해야함)

- SUM() 또는 MIN(), MAX() 같은 집계 함수와 윈도우 함수가 사용된 서브쿼리
- DISTINCT가 사용된 서브쿼리
- GROUP BY나 HAVING이 사용된 서브쿼리
- LIMIT이 사용된 서브쿼리
- UNION 또는 UNION ALL을 포함하는 서브쿼리
- SELECT 절에 사용된 서브쿼리
- 값이 변경되는 사용자 변수가 사용된 서브쿼리

### **인비저블 인덱스(use_invisible_indexes)**

---

MySQL 8.0 부터는 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어하는 기능을 제공한다.

```sql
# 옵티마이저가 ix_hiredate 인덱스를 사용하지 못하게 변경
ALTER TABLE employees ALTER INDEX ix_hiredate INVISIBLE;

# 옵티마이저가 ix_hiredate 인덱스를 사용할 수 있게 변경
ALTER TABLE employees ALTER INDEX ix_hiredate VISIBLE;

# 옵티마이저가 INVISIBLE 상태의 인덱스도 볼 수 있게 설정 (기본값 off)
SET optimizer_switch='use_invisible_indexes=on';
```

### **스킵 스캔(skip_scan)**

---

인덱스의 핵심은 값이 정렬돼 있는다는 것이며, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다. 

- 인덱스 스캔은 제한적이긴 하지만 선행 컬럼이 카디널리티가 낮을 때 인덱스의 제약 사항을 뛰어넘을 수 있는 최적화 기법이다.

```sql
# 현재 세션에서 인덱스 스킵 스캔 최적화를 활성화
SET optimizer_switch='skip_scan=on';

# 현재 세션에서 인덱스 스킵 스캔 최적화를 비활성화
SET optimizer_switch='skip_scan=off';

# 특정 테이블에 대해 인덱스 스킵 스캔을 사용하도록 힌드를 사용
SELECT /*+ SKIP_SCAN(employees)*/ COUNT(*)
FROM employees
WHERE birth_date>='1965-02-01';

# 특정 테이블과 인덱스에 대해 인덱스 스킵 스캔을 사용하도록 힌트를 사용
SELECT /*+ SKIP_SCAN(employees ix_gender_birthdate)*/ COUNT(*)
FROM employees
WHERE birth_date>='1965-02-01';

# 특정 테이블에 대해 인덱스 스킵 스캔을 사용하지 않도록 힌트를 사용
SELECT /*+ NO_SKIP_SCAN(employees)*/ COUNT(*)
FROM employees
WHERE birth_date>='1965-02-01';
```

### **해시 조인(hash_join)**

---

MySQL 8.0.20 부터 블록 네스티드 루프 조인은 더이상 사용되지 않고, 네스티드 루프 조인을 사용할 수 없는 경우에는 항상 해시 조인이 사용되도록 바뀌었다.

- MySQL 서버는 범용 RDBMS이며 OLTP 처리를 위한 DB 서버 이므로 응답속도가 중요하기 때문이다.
- 해시 조인 쿼리는 최고 스루풋 전략에 적합하며, 네스티드 루프 조인은 최고 응답 속도 전략에 적합하다.

**해시 조인은 빌드 단계와 프로브 단계로 나뉘어 처리된다.**

- `EXPLAIN FORMAT=TREE` 명령 또는 `EXPLAIN ANALYZE` 명령을 사용하면 빌드 테이블과 프로브 테이블을 식별할 수 있다.

**빌드 단계:** 조인 대상 테이블 중에서 레코드 건수가 적어서 해시 테이블로 만들기에 용이한 테이블을 골라서 메모리에 해시 테이블을 생성(빌드)하는 작업을 수행

**프로브 단계:** 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 과정을 의미

해시 테이블을 메모리에 저장할 때 MySQL 서버는 `join_buffer_size` 시스템 변수로 크기를 제어할 수 있는 조인 버퍼를 사용한다. (기본 256KB)

- 빌드 테이블의 레코드를 읽어서 메모리에 해시 테이블을 생성하고 프로브 테이블을 스캔하면서 메모리에 생성된 해시 테이블에서 레코드를 찾아서 결과를 사용자에게 반환한다.
- 레코드 건수가 많아 조인 버퍼의 공간이 부족할 경우 MySQL 서버는 빌드 테이블과 프로브 테이블을 하나의 청크가 조인 버퍼보다 작도록 적당한 크기로 분리한 다음 위에 처럼 동작한다.
    - 디스크에 저장된 청크 개수만큼 반복 처리해서 완성된 조인 결과를 만들어 낸다.

메모리에서 모두 처리 가능한 경우에 `클래식 해시 조인` 알고리즘을 사용하고 해시 테이블이 조인 버퍼 메모리보다 큰 경우 `그레이스 해시 조인` 알고리즘을 하이브리드하게 활용할 수 있다.

### **인덱스 정렬 선호(prefer_ordering_index)**

---

MySQL 옵티마이저는 ORDER BY, GROUP BY를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해서 실행된다.

WHERE 조건에서 많이 걸러진다면 ORDER BY 보다 WHERE 조건에서 사용되는 인덱스를 사용하는게 효율적이지만 ORDER BY를 위한 인덱스에 가중치 때문에 선택되지 못할 수 있다.

- IGNORE INDEX 힌트를 사용할 수 있지만 MySQL 8.0.21 버전 부터 ORDER BY를 위한 인덱스에 너무 가중치를 부여하지 않도록 prefer_ordering_index 옵티마이저 옵션이 추가됐다. (기본값 ON)

```sql
# 현재 커넥션에서만 prefer_ordering_index 옵션을 비활성화
SET SESSION optimizer_switch='prefer_ordering_index=OFF';

# 현재 쿼리에 대해서만 prefer_ordering_index 옵션을 비활성화
SELECT /*+ SET_VAR(optimizer_switch='perfer_ordering_index=OFF') */
...
FROM
```

## **조인 최적화 알고리즘**

MySQL에는 최적화된 조인 실행 계획 수립을 위한 Exhaustive/Greedy 검색 알고리즘이 있다.

- 테이블 개수가 많아지면 최적화된 실행 계획을 찾는 것이 상당히 어려워지고, 하나의 쿼리에서 조인되는 테이블의 개수가 많아지면 실행 계획을 수립하는 데만 몇 분이 걸릴 수 있어 왜 이런 현상이 생기는지 알아야 한다.

### **Exhaustive 검색 알고리즘**

---

Exhaustive 검색 알고리즘은 MySQL 5.0 이전에 사용되던 조인 최적화 기업으로, FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다.

- 테이블이 20개라면 가능한 조인 조합은 모두 20!(3628800)개가 되며 10개만 넘어도 실행 계획을 수립하는 데 몇 분이 걸린다. (20개에서 1개만 늘어나도 21배의 시간이 걸린다.)

### **Greedy 검색 알고리즘**

---

Greedy 검색 알고리즘은 Exhaustive 검색 알고리즘의 단점을 보완하기 위해 MySQL 5.0 부터 사용되기 시작한 알고리즘이다.

1. 전체 N개의 테이블 중에서 `optimizer_search_depth(기본값 62)` 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
2. 1번에서 생성된 조인 조합 중에서 최소 비용의 실행 계획 하나를 선정
3. 2번에서 선정된 실행 계획의 첫 번째 테이블을 `부분 실행 계획`의 첫 번째 테이블로 선정
4. 전체 N-1개의 테이블 중에서 `optimizer_search_depth` 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 `부분 실행 계획`에 대입해 실행 비용을 계산
6. 5번의 비용 계산 결과, 최적의 실행 계획에서 두 번째 테이블을 3번에서 생성된 `부분 실행 계획`의 두 번째 테이블로 선정
7. 남은 테이블이 모두 없어질 때까지 4~6번 과정을 반복 실행하면서 `부분 실행 계획`에 테이블의 조인 순서를 기록
8. 최종적으로 `부분 실행 계획`이 테이블의 조인 순서로 결정됨

조인 최적화를 위한 시스템 변수로 `optimizer_prune_level`과 `optimizer_search_depth`가 제공된다.

- `optimizer_search_depth` 시스템 변수에 설정된 값에 따라 조인 최적화의 비용이 상당히 줄어들 수 있다.

### `optimizer_prune_level`

---

`optimizer_prune_level`: 0~62까지의 정숫값을 설정할 수 있다.

0: Greedy 검색을 위한 최적의 조인 검색 테이블의 개수를 MySQL 옵티마이저가 자동으로 결정한다.

1~62: Greedy 검색 대상을 지정된 개수로 한정해서 최적의 실행 계획을 산출한다.

조인 테이블의 개수가 `optimizer_search_depth` 값보다 클 때

- `optimizer_search_depth` 만큼의 테이블은 Exhaustive 검색이 사용되고 나머지 테이블은 Greedy 검색이 사용된다.

조인 테이블의 개수가 `optimizer_search_depth` 값보다 작을 때

- Exhaustive 검색만 사용된다.
- 기본값은 62라서 많은 테이블이 조인되는 쿼리에서는 상당히 부담이 될 수도 있다.

`optimizer_prune_level` 시스템 변수가 0으로 설정된 경우에는 `optimizer_search_depth` 의 설정값이 쿼리의 성능에 심각한 영향을 미칠 수 있으니 `optimizer_search_depth`를 4~5 정도로 설정하는 것이 좋다.

### `optimizer_prune_level`

---

`optimizer_prune_level`은 MySQL 5.0부터 추가된 `Heuristic 검색`이 작동하는 방식을 제어한다.

`Heuristic 검색`은 다양한 조인 순서의 비용을 계산하는 도중 이미 계산했던 조인 순서의 비용보다 큰 경우에는 언제든지 중간에 포기할 수 있다. 그리고 아우터 조인으로 연결되는 테이블은 우선순위에서 제거하는 등 경험 기반의 최적화도 `Heuristic 검색` 최적화에 포함돼 있다.

0으로 설정: 경험 기반의 `Heuristic` 최적화가 적용되지 않는다.

1으로 설정(기본값): 옵티마이저는 조인 순서 최적화에 경험 기반의 `Heuristic` 알고리즘을 사용한다.

실제 `Heuristic` 조인 최적화는 조인 대상 테이블이 몇 개 되지 않더라도 상당한 성능 차이를 내기 때문에 특별한 요건이 없다면 `optimizer_prune_level`을 0으로 설정하지 말자

## **9.4 쿼리 힌트**

서비스 개발자나 DBA보다 MySQL 서버가 부족한 실행 계획을 수립할 때 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 힌트를 제공할 수 있다.

- 인덱스 힌트, 옵티마이저 힌트

### 인덱스 힌트

---

STRAIGHT_JOIN, USE INDEX 등을 포함한 인덱스 힌트들을 모두 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용되던 기능들이다. ANSI-SQL 표준을 준수하지 못하는 인덱스 힌트보다 옵티마이저 힌트를 사용하자

```sql
# 인덱스 힌트
SELECT * FROM employees USE INDEX(ix_firstname)
WHERE ...
# 옵티마이저 힌트
SELECT /*+ INDEX(employees ix_firstname) */ * FROM employees
WHERE ...
```

- ANSI-SQL 표준을 준수하는 옵티마이저 힌트들은 MySQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석된다.
- 인덱스 힌트는 SELECT 명령과 UPDATE 명령에서만 사용할 수 있다.

### **STRAIGHT_JOIN**

---

STRAIGHT_JOIN은 옵티마이저 힌트인 동시에 조인 키워드이기도 하다. 

- `STRAIGHT_JOIN`은 SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다. (`JOIN_FIXED_ORDER` 옵티마이저 힌트와 동일한 효과를 낸다.)
- `STRAIGHT_JOIN` 힌트는 한번 사용되면 FROM 절의 모든 테이블에 대해 조인 순서가 결정되는 효과를 내며 `JOIN_ORDER`, `JOIN_PREFIX`, `JOIN_SUFFIX`는 일부 테이블의 조인 순서에 대해서만 제안하는 힌트다.

### **USE INDEX / FORCE INDEX / IGNORE INDEX**

---

인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다. 옵티마이저가 3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러 개 존재하는 경우에는 실수하는데 이때 강제로 특정 인덱스를 사용하도록 힌트를 추가한다.

- **USE INDEX:** 가장 자주 사용되는 인덱스 힌트로, 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트 (항상 힌트로 제공한 인덱스를 사용하는건 아니며 옵티마이저에 대한 영향력이 충분히 크다.)
- **FORCE INDEX:** `USE INDEX`와 동일한 기능을 수행하지만, FORCE INDEX는 옵티마이저에게 미치는 영향이 더 강한 힌트로 생각하면 된다. (`USE INDEX`에서 사용하지 않았던 힌트도 동일하게 사용하지 않는 경우가 대부분이다. 거의 사용X)
- **IGNORE INDEX:** `USE INDEX`와 `FORCE INDEX`와는 반대로 옵티마이저에게 특정 테이블의 인덱스를 사용하지 않도록 권장하는 힌트

선택적으로 인덱스 용도를 명시해줄 수 있는데 인덱스 힌트에 용도가 명시되지 않으면 3가지 용도로 사용한다.
(용도는 옵티마이저가 대부분 최적으로 선택하기 때문에 인덱스의 용도까지는 크게 고려하지 않아도 된다.)

- USE INDEX FOR JOIN: JOIN이라는 키워드는 테이블 간의 조인 뿐만 아니라 레코드를 검색하기 위한 용도까지 포함한다. MySQL 서버에서는 하나의 테이블로부터 데이터를 검색하는 작업도 JOIN이라고 표현하기 때문이다.
- USE INDEX FOR ORDER BY: 명시된 인덱스를 ORDER BY 용도로만 사용할 수 있게 제한한다.
- USE INDEX FOR GROUP BY: 명시된 인덱스를 GROUP BY 용도로만 사용할 수 있게 제한한다.

### 가장 훌륭한 최적화

---

그 쿼리를 서비스에서 없애 버리거나 튜닝할 필요가 없게 데이터를 최소화하는 것이며 그것이 어렵다면 데이터 모델의 단순화를 통해 쿼리를 간결하게 만들어야 한다.

### **SQL_CALC_FOUND_ROWS**

---

SQL_CALC_FOUND_ROWS가 포함된 쿼리의 경우 LIMIT을 만족하는 수만큼의 레코드를 찾았다고 하더라도 끝까지 검색을 수행한다. (성능 향상이 아닌 개발자의 편의를 위해 만들어진 힌트)

```sql
SELECT SQL_CALC_FOUND_ROWS * FROM employees WHERE first_name='Georgi' LIMIT 0, 20;
SELECT FOUND_ROWS() AS total_record_count;
```

- SQL_CALC_FOUND_ROWS는 조건을 만족하는 레코드 전부를 읽어 봐야하기 때문에 랜덤 I/O가 조건을 만족하는 레코드 전체 개수만큼 일어나게 된다.
- 카운트 쿼리는 인덱스로 튜닝하면 훨씬 더 빠른 결과를 만들어낼 수 있기 때문에 일반적인 관점에서 카운터용 쿼리와 데이터를 조회하는 쿼리를 분리하는 것이 더 효과적이다.
- SELECT 문장이 UNION, UNION DISTINCT으로 연결된 경우 SQL_CALC_FOUND_ROWS 힌트를 사용해도 FOUND_ROWS() 함수로 정확한 레코드 건수를 가져올 수 없는 문제가 있다.

### **옵티마이저 힌트 종류**

---

- 인덱스 : 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
- 테이블 : 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
- 쿼리 블록 : 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트로서, 특정 쿼리 블록의 이름을 명시하는 것이 아니라 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
- 글로벌 : 전체 쿼리에 대해서 영향을 미치는 힌트

모든 인덱스 수준의 힌트는 반드시 테이블명이 선행돼야 한다.

- 인덱스 수준의 옵티마이저 힌트(INDEX)를 사용하는 경우 인덱스명을 사용해야 하는데 그 인덱스를 가진 테이블명을 먼저 명시해야 한다.

```sql
SELECT /*+ INDEX(employees ix_firstname) */ * FROM employees WHERE ...;
SELECT /*+ NO_INDEX(employees ix_firstname) */ * FROM employees WHERE ...;
```

EXPLAIN 명령은 파싱된 쿼리의 재조립된 결과를 보여주는 용도로 1개의 경고 메시지를 출력한다.

```sql
EXPLAIN SELECT /*+ INDEX(ix_firstname) */ * FROM employees WHERE ...;
SHOW WARNINGS;
```

- 힌트에 오류가 있다면 2개의 경고 메시지를 출력하기 때문에 익숙하지 않은 힌트를 사용할 경우에 EXPLAIN 명령으로 힌트 문법상 오류가 있지 않은지 확인하자.

### 쿼리 블록 내부의 테이블을 외부 쿼리 블록에서 힌트를 사용하는 방법

---

**쿼리 블록:** SELECT 키워드로 시작하는 서브쿼리 영역을 말한다. 

- 특정 쿼리 블록을 외부 쿼리 블록에서 사용하려면 `QB_NAME("이름")`  힌트를 이용해 해당 쿼리 블록에 이름을 부여해야 한다.

세미 조인 최적화를 통해 조인으로 처리될 것을 예상하고 JOIN_ORDER 힌트 사용 예시

```sql
EXPLAIN
SELECT /*+ JOIN_ORDER(e, s@subq1) */
	COUNT(*)
FROM employees e
WHERE ... AND e.emp_no IN (SELECT /*+ QB_NAME(subq1) */ s.emp_no 
													 FROM salaries s
													 WHERE ...);
```

- 조인의 순서로 외부 쿼리 블록의 employees 테이블과 서브쿼리 블록의 salaries 테이블을 순서대로 조인하게 힌트를 사용

### **MAX_EXECUTION_TIME**

---

옵티마이저 힌트 중에서 유일하게 쿼리의 실행 계획에 영향을 미치지 않는 힌트이며, 단순히 쿼리의 최대 실행시간을 설정하는 힌트다. (ms 단위)

### **SET_VAR**

---

MySQL 서버의 시스템 변수들 또한 쿼리의 실행 계획에 상당한 영향을 미치며 SET_VAR를 통해서 쿼리 실행을 위한 시스템 변수를 제어할 수 있다.

- 모든 시스템 변수를 SET_VAR 힌트로 조정할 수는 없다.

**`예시`**

join_buffer_size 시스템 변수의 경우 쿼리에 아무런 영향을 미치지 않을 것처럼 보이지만 MySQL 서버의 옵티마이저는 조인 버퍼의 공간이 충분하면 조인 버퍼를 활용하는 형태의 실행 계획을 선택할 수도 있다. 

- 소트 버퍼의 크기를 일시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상시키는 용도로도 선택할 수 있다.

옵티마이저 힌트로 부족한 경우 optimizer_switch 시스템 변수를 제어해야 할 수도 있다. 

### **SEMIJOIN & NO_SEMIJOIN**

---

다른 최적화 전략으로 우회하는 것이 더 나은 성능을 낼 수도 있기 때문에 **NO_SEMIJOIN** 힌트도 제공된다.

| 최적화 전략 | 힌트 |
| --- | --- |
| Duplicate Weed-out | SEMIJOIN(DUSPWEEDOUT) |
| FirstMatch | SEMIJOIN(FIRSTMATCH) |
| Loose Scan | SEMIJOIN(LOOSESCAN) |
| Materialization | SEMIJOIN(MATERIALIZATION) |
| Table Pull-out | 없음 |
- `Table Pull-out` 전략을 사용할 수 있다면 항상 더 나은 성능을 보장하기 때문에 별도로 힌트를 사용할 수 없다.

### **SUBQUERY**

---

서브쿼리 최적화는 세미 조인 최적화가 사용되지 못할 때 사용하는 최적화 방법으로, 서브쿼리는 다음 2가지 형태로 최적화할 수 있다.

| 최적화 방법 | 힌트 |
| --- | --- |
| IN-to-EXISTS | SUBQUERY(INTOEXISTS) |
| Materialization | SUBQUERY(MATERIALIZATION) |

세미 조인 최적화는 주로 IN 형태의 쿼리에 사용될 수 있지만 안티 세미 조인의 최적화에는 사용될 수 없다. 그래서 안티 세미 조인 최적화에는 위 2가지 최적화가 사용된다.

### **BNL & NO_BNL & HASHJOIN & NO_HASHJOIN**

---

해시 조인 알고리즘이 기존의 블록 네스티드 루프 조인까지 대체하도록 개선되었다. 그래서 MySQL 8.0.20 버전부터는 `블록 네스티드 루프 조인`은 MySQL 서버에서 더 이상 사용되지 않는다.

- 인덱스가 적절히 준비돼 있다면 해시 조인은 거의 사용되지 않으며 네스티드 루프 조인을 실행하기 때문에 인덱스를 모두 제거하거나 사용하지 못하게 해야 해시 조인 알고리즘이 사용될 것이다.

MySQL 8.0.20과 이후 버전에서는 해시 조인을 유도하거나 해시 조인을 사용하지 않게 하고자할 때 `BNL`과 `NO_BNL` 힌트를 사용해야 한다.

- MySQL 8.0.18 버전에서만 `HASHJOIN`과 `NO_HASHJOIN`이 유효하며, 그 이후버전에서는 효력이 없다.

### **JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX**

---

STRAIGHT_JOIN 힌트는 조인 순서를 일부만 강제하고 나머지는 옵티마이저에게 순서를 결정하게 맞기는 것이 불가능하다.

**단점을 보완하기 위해 옵티마이저 힌트에는 4개의 힌트를 제공한다.**

- JOIN_FIXED_ORDER : STRAIGHT_JOIN 힌트와 동일하게 FROM 절의 테이블 순서대로 조인을 싱행하게 하는 힌트
- JOIN_ORDER : FROM 절에 사용된 테이블의 순서가 아니라 힌트에 명시된 테이블의 순서대로 조인을 실행
    
    ```sql
    # FROM 절에 나열된 테이블의 순서대로 조인
    SELECT /*+ JOIN_FIXED_ORDER() */ * FROM .. JOIN ...
    # 일부 테이블에 대해서만 조인 순서를 나열
    SELECT /*+ JOIN_FIXED_ORDER(d, de) */ * FROM .. JOIN ...
    ```
    
- JOIN_PREFIX : 조인에서 드라이빙 테이블만 강제하는 힌트
- JOIN_SUFFIX : 조인에서 드리븐 테이블(가장 마지막에 조인돼야 할 테이블들)만 강제하는 힌트

### **MERGE & NO_MERGE**

---

MySQL 옵티마이저가 내부 쿼리(인라인 뷰)를 외부 쿼리와 병합하는 것이 나을 수도 있고, 때로는 내부 임시 테이블을 생성하는 것이 더 나은 선택일 수 있다.

- MySQL 옵티마이저가 최적의 방법을 선택하지 못할 때 MERGE, NO_MERGE(임시 테이블 생성)힌트를 줄 수 있다.

### **INDEX_MERGE & NO_INDEX_MERGE**

---

여러 인덱스를 통해 검색된 레코드로부터 교집합 또는 합집합만 구하는 인덱스 머지 사용 여부를 제어하고자 할 때 INDEX_MERGE ,NO_INDEX_MERGE를 사용할 수 있다.

### **NO_ICP(ICP, Index Condition Pushdown)**

---

MySQL 옵티마이저에서는 ICP 힌트는 제공되지 않는다.

- 인덱스 컨디션 푸시다운(ICP) 최적화는 사용가능하다면 항상 성능 향상에 도움이 되기 때문이다.
- Extra 칼럼의 `Using index condition` 문구를 통해서 최적화 되었는지 확인 가능하다.

컨디션 푸시다운으로 인해 여러 실행 계획의 비용 계산이 잘못된다면 결과적으로 잘못된 실행 계획을 수립하게 될 수도 있다.

- A 인덱스에서 인덱스 컨디션 푸시다운이 가능해 비용이 낮게 예측되지만 B 인덱스를 사용하는게 실제 서비스에서 효율적일 때

테이블의 데이터 분포는 항상 균등한것이 아니기 때문에 A 인덱스를 완전히 사용하지 못하게 하거나 B 인덱스를 선호하게 하는 것은 좋지 않은 선택일 수도 있다.

- ICP 비활성화 힌트를 통해 조금 더 유연하고 정확하게 실행 계획을 선택할 수 있다.

### **SKIP_SCAN & NO_SKIP_SCAN**

---

인덱스 스킵 스캔은 인덱스의 선행 칼럼에 대한 조건 없이도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 매우 훌륭한 최적화 기능이다.

- 선행 칼럼이 가지는 유니크한 값의 개수가 많아진다면 인덱스 스킵 스캔의 선응은 오히려 더 떨어지게 되므로 옵티마이저 힌트를 통해 인덱스 스킵 스캔을 사용하지 않게 할 수 있다.

### **INDEX & NO_INDEX**

---

INDEX, NO_INDEX 옵티마이저 힌트는 예전 MySQL 서버에서 사용되던 인덱스 힌트를 대체하는 용도로 제공한다.

| 인덱스 힌트 | 옵티마이저 힌트 |
| --- | --- |
| USE INDEX | INDEX |
| USE INDEX FOR GROUP BY | GROUP_INDEX |
| USE INDEX FOR ORDER BY | ORDER_INDEX |
| IGNORE INDEX | NO_INDEX |
| IGNORE INDEX FOR GROUP BY | NO_GROUP_INDEX |
| IGNORE INDEX FOR ORDER BY | NO_ORDER_INDEX |
