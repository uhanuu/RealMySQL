# 트랜잭션과 잠금
**트랜잭션: 작업의 데이터 정합성을 보장한다.**

- 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능

**잠금(Lock):** 동시성을 제어하기 위한 기능

**격리 수준:** 하나의 트랜잭션 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 말한다.

## 트랜잭션
MyISAM이나 MEMORY 같이 트랜잭션을 지원하지 않는 스토리지 엔진의 테이블이 InnoDB 스토리지 엔진보다 더 많은 고민거리를 만들어 낸다.

### MySQL에서의 트랜잭션

---

트랜잭션이란 논리적인 작업 셋 자체가 100% 적용되거나(Commit) 아무것도 적용되지 않아야(Rollback)함을 보장해 주는 것이다.

```sql
CREATE TABLE tab_myisam
( fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=MyISAM;
INSERT INTO tab_myisam (fdpk) VALUES (3);

CREATE TABLE tab_innodb
( fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=INNODB;
INSERT INTO tab_innodb (fdpk) VALUES (3);
```

**AUTO-COMMIT 모드**

- 두 개의 스토리지에 아래 INSERT 쿼리를 실행한다면 pk 3이 중복되어 두 table 모두 오류가 발생한다.

```sql
// myisam은 1, 2가 저장되지만 innodb는 1, 2가 저장되지 않는다.
INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
```

**MyISAM과 InnoDB 차이점**

**MyISAM :** (1),(2) 값에 대하여 레코드 삽입 결과가 성공하고 (3)이 실패했더라도 (1),(2)값이 남아 있게 된다.

- **부분 업데이트(Partial Update)**라고 표현하며 테이블 데이터 정합성을 맞추는데 상당히 어려운 문제를 만들어 낸다.

**InnoDB :** 쿼리 중 일부라도 오류가 발생하며 전체를 원 상태로 만든다는 트랜잭션의 원칙대로 INSERT 문장을 실행하기 전 상태로 그대로 복구한다. 따라서 (1)과 (2)의 삽입 결과는 되돌려진다.

MyISAM 스토리지 엔진을 사용할 때 위 정합성 문제를 해결하려면 if문을 사용해서 분기처리 해야 하지만, innodb는 Rollback을 통해서 고민해야 하는 부분을 많이 줄일 수 있다.

### **트랜잭션 범위를 최소화하자**

---

- 트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
- 트랜잭션은 InnoDB 엔진에서 언두 로그를 예상보다 오랫동안 길게 남아 있게 할 수 있으며 적용해야하는 최적의 구간에만 트랜잭션을 적용해야한다.

## MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 **스토리지 엔진 레벨**과 **MySQL 엔진 레벨**로 나눌 수 있다.

MySQL 엔진 레벨의 잠금: 모든 스토리지 엔진에 영향을 준다.

- 테이블 락: 테이블 데이터 동기화를 위해 건다.
- 메타데이터 락: 테이블의 구조를 잠근다.
- 네임드 락: 사용자의 필요에 맞게 사용할 수 있다.

스토리지 엔진 레벨의 잠금: 스토리지 엔진 간 상호 영향을 미치지 않는다.

### 글로벌 락 (MySQL 서버 전체 영향)

---

FLUSH TABLES WITH READ LOCK 명령으로 획득할 수 있고 MySQL에서 제공하는 가장 범위가 큰 락이다.

- 한 세션에서 글로벌 락 획득 시 다른 세션의 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 대기 상태로 남는다.
- MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때 사용한다.

InnoDB 스토리지 엔진이 일반화되면서 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없어졌다

### 테이블 락

---

개별 테이블 단위로 설정되는 잠금으로 명시적 혹은 묵시적으로 특정테이블의 락을 획득할 수 있다.

**👻 명시적**

획득하는 방법: LOCK TABLES table_name [READ | WRITE]

반납하는 방법: UNLOCK TABLES

- 테이블 락은 MyISAM뿐 아니라 InnoDB도 동일하게 설정한다.
- 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미친다.

**👊🏻 묵시적**

`MyISAM`이나 `MEMORY` 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.

- 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제된다.

`InnoDB` 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공한다.

- 락이 설정되지만 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는(DDL) 경우에만 영향을 미친다.

### 네임드 락

---

`GET_LOCK()` 함수를 이용해 `임의의 문자열`에 대해 잠금을 설정할 수 있다.

- 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 DB 객체가 아니라 사용자가 지정한 문자열에 대해 잠금을 획득하고 반납하는 잠금이다.

SELECT GET_LOCK('mylock', 2);

- mylock이라는 문자열에 대해 잠금을 획득하고, 이미 잠금을 사용 중이면 2초 동안만 대기한다.

SELECT IS_FREE_LOCK('mylock');

- mylock이라는 문자열에 대해 잠금이 설정돼 있는지 확인한다.

SELECT RELEASE_LOCK('mylock');

### **메타데이터 락**

---

데이터베이스 객체(테이블이나 뷰)의 이름이나 구조를 변경하는 경우 획득하는 잠금이다.

- RENAME TABLE tab_a TO tab_B 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

## **InnoDB 스토리지 엔진 잠금**

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에 레코드 기반의 잠금 방식을 탑재하고 있다.

- 레코드 기반의 잠금 방식 덕분에 InnoDB 엔진은 높은 동시성 처리를 제공할 수 있다.

### **InnoDB 스토리지 엔진의 잠금**

---

- 레코드 기반의 잠금 기능 제공하며 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락 또는 테이블 락으로 레벨업 되는 경우는 없다
- 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용한다.
- 프라이머리 키 또는 유니크 인덱스(클러스터 인덱스)에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.

**레코드 락(Record lock, Record only lock)**

InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.

- 인덱스가 하나도 없는 테이블의 경우 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

**갭 락과 넥스트 키 락의 목적**

바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.

**갭 락(Gap lock)**

레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만 잠근다.

- 레코드와 레코드 사이에 새로운 레코드가 생성(INSERT)되는 것을 제어한다.
- 넥스트 키 락의 일부로 자주 사용된다.

**넥스트 키 락(Next Key lock)**

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이다.

- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다.
- innodb_locks_unsafe_for_binlog 시스템 변수가 비활성화되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다.
- 넥스트 키락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생하여 최신 버전에서는 ROW 포맷의 바이너리 로그가 기본 설정으로 변경되어 넥스트 키 락이나 갭 락을 줄일 수 있다.

**자동 증가 락**

여러 레코드가 저장되는 경우 중복되지 않고 저장된 순서대로 증가하는 인련번호 값을 가져야 하기에 자동으로 내부적으로 auto increment lock을 사용한다.

- INSERT, REPLACE같이 새로운 레코드를 저장하는 쿼리에만 필요하다.
(UPDATE나 DELETE에서는 필요하지 않다.)

```sql
MySQL 8.0 버전 부터는 바이너리 로그 포맷으로 ROW 포맷이 기본값이기 때문에 innodb_auto_lock_mode = 2가 기본값이다. 
STATEMENT 포맷의 바이너리 로그를 사용한다면 innodb_auto_lock_mode = 1로 변경해서 사용하자.
```

### 인덱스와 잠금

---

InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.

- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.

해당 조건으로 검색되는 레코드 개수

```sql
// 253건
SELECT COUNT(*) FROM employees WHERE first_name = 'Georgi'
// 1건
SELECT COUNT(*) FROM employees WHERE first_name = 'Georgi' AND last_name = 'Klassen'
```

employees 테이블에 다음과 같은 DML 쿼리를 사용한다고 했을 때 몇 개의 레코드에 락이 걸릴까?

```sql
UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
```

- employees 테이블에 first_name 컬럼에만 인덱스가 만들어져 있으면 last_name 컬럼은 인덱스가 없기 때문에 253건의 레코드가 모두 잠긴다.

**인덱스 설계가 중요한 이유**

- 적절한 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어져서 한 세션에서 update를 하는 중에는 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생한다.
- 인덱스가 하나도 없다면 테이블을 풀 스캔하면서 UPDATE를 진행하는데 이 과정에서 테이블에 있는 모든 레코드를 잠그게된다.

## **MySQL의 격리 수준(isolation level)**

여러 트랜재션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

|  | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| --- | --- | --- | --- |
| READ UNCOMMITTED | 발생 | 발생 | 발생 |
| READ COMMITTED | 없음 | 발생 | 발생 |
| REPEATABLE READ | 없음 | 없음 | 발생 (InnoDB는 없음) |
| SERIALIZABLE | 없음 | 없음 | 없음 |
- SERIALIZABLE 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않는다.
- REPEATABLE READ 격리 수준에서는 THANTOM READ가 발생할 수 있지만, InnoDB에서는 독특한 특성 때문에 발생하지 않는다.
- 일반적인 온라인 서비스 용도의 DB는 READ COMMITTED와 REPEATABLE READ중 하나를 사용한다.

### 5.4.1 READ UNCOMMITTED

---
더티 리드가 허용되는 격리 수준을 뜻한다.

> **DIRTY READ**: 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
- 더티 리드 현상은 데이터가 나타났다가 사라졌다 하는 현상을 초래한다.
- RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.
- MySQL을 사용한다면 최소한 READ COMMITTED 이상을 사용하자

### READ COMMITTED

---
- NON-REPEATABLE READ라는 부정합 문제 존재하며 더티 리드를 허용하지 않는다.
> NON-REPEATABLE READ: 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성을 어겼다는 뜻
- 만약 커밋 안 된 트랜잭션 안의 데이터를 읽을 때는, 데이터 변경 전인 언두 로그 데이터를 읽는다.
- 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결된다면 문제가 될 수도 있다.

### REPEATABLE READ

---
**MySQL의 InnoDB 스토리지 엔진의 기본 격리 수준으로 NON-REPEATABLE READ 부정합이 발생하지 않는다.**
- 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함돼 있다. 그리고 언두 영역의 백업된 데이터는 InnoDB가 불필요하다고 판단하는 시점에 주기적으로 삭제한다.

### SERIALIZABLE

---
**하나의 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.**
- InnoDB는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ가 발생하지 않기 때문에 굳이 사용하지 않아도 된다.
